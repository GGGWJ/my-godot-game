# 战斗系统重构与调试总结

## 1. 重构背景
为了解决项目日益复杂的代码耦合问题（"面条代码"），我们将原有的单一 `Entity` 继承结构拆分为 **组件化架构 (Component-Based Architecture)**。

主要改动包括：
*   **功能剥离**: 将生命值管理拆分为 `HealthComponent`，移动逻辑拆分为 `MoverComponent`。
*   **状态机引入**: 引入 `FSM` (Finite State Machine) 管理 `Idle`, `Move`, `Chase`, `Attack` 等状态，替代原本混乱的 `_physics_process` 判断。
*   **标准化战斗接口**: 废弃原本直接调用的伤害函数，建立 `Hitbox` (攻击盒) 与 `Hurtbox` (受击盒) 的 **发布-订阅模式**。所有的伤害传递都通过 `DamageData` 对象进行。

## 2. 遇到的问题：伤害判定失效
在重构完成后，出现了一个严重 Bug：
*   **现象**: 敌人（骷髅、恶魔）的攻击表现正常（有攻击动作、有火球飞行、有碰撞销毁的回调），但玩家并未受到伤害，血量没有扣除。

## 3. 问题根源分析
经过详细的代码走查和日志埋点（Debugging），我们锁定了两个核心问题：

### A. Godot 节点生命周期陷阱 (The Review of Lifecycle)
**问题描述**: 恶魔的火球 (`Hitbox`) 击中玩家的 `Hurtbox` 时，日志显示 `handle_hit` 被触发，但 `HealthComponent` 为 `null`。
**原因**:
*   在 Godot 中，`_ready()` 的调用顺序是 **“从子到父”** (Children first, Parent last)。
*   `Hurtbox` 是 `Player` 的子节点。当 `Hurtbox._ready()` 执行时，`Player`（父节点）的 `_ready()` 尚未执行。
*   如果 `HealthComponent` 的初始化或引用赋值是在 `Player._ready()` 中进行的，那么 `Hurtbox` 在此时尝试获取它就会失败（拿到空值）。

### B. 默认值缺失
**问题描述**: 骷髅的近战攻击命中后，传递的伤害值为 0。
**原因**: `AbilityDealDamage` 组件过度依赖外部 `Stats` 资源。如果资源未正确加载或配置为空，组件内部的 `damage` 变量初始化为 0，导致攻击无效。

## 4. 解决方案

### 修复方案
1.  **引入由于 (Lazy Loading) 机制**:
    *   修改 `Hurtbox.gd`。不在 `_ready` 中“一锤子买卖”地获取引用。
    *   在 `handle_hit(damage_data)` 被调用时（此时游戏肯定已经初始化完毕），如果发现 `health_component` 为空，则再次尝试从父节点获取。
    ```gdscript
    func handle_hit(damage_data: DamageData) -> void:
        # 延迟获取，防止初始化顺序带来的空引用
        if not health_component and entity:
            health_component = entity.health_component
        ...
    ```

2.  **防御性编程**:
    *   在 `AbilityDealDamage.gd` 中设置默认伤害值，并优化了伤害计算逻辑，确保在资源缺失时也有兜底伤害。

3.  **调试可视化**:
    *   在 `Hitbox`, `Hurtbox`, `Entity` 关键节点植入了中文调试日志 (`print`)，确保能实时监控 "谁 -> 打了谁 -> 多少伤害"。

## 5. 架构收益总结
经过这次修复，现在的战斗系统具备了极强的扩展性：
*   **解耦**: 攻击者不需要知道受害者是 `Player` 还是 `Wall`，只需要撞击 `Hurtbox`。
*   **统一**: 无论是近战（骷髅）还是远程（火球），底层都复用同一套 `Hitbox` -> `Hitbox` 逻辑。
*   **健壮**: 生命周期的修复让组件的组装不再依赖特定的节点顺序。
