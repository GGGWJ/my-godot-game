# 学习报告：组件化与状态机实践 (Components & FSM)

## 1. 核心目标：消除“上帝类” (Eliminating God Objects)
随着项目扩展，`Entity` 基类容易堆积过多职责（血量、移动、AI、音效）。本次重构通过“功能抽离”实现了从继承到组合的转变，确保代码在长时间开发中保持清晰。

## 2. 组件化方案：肉体与机能的分离

### 驱动组件 (Components)
我们将特定的数值处理逻辑封装为独立的子节点，挂载到实体下：
*   **HealthComponent**: 专门负责生命值管理（增减血、死亡判定）。
    *   *优势*: 逻辑独立，可复用至非生物（如可破坏木桶）。
    *   *存取模式*: 通过 `Entity.current_health` 存取器保持向后兼容，但底层计算全量外包。
*   **MoverComponent**: 专门负责物理位移。
    *   *职责*: 计算加速度、摩擦力、平滑转弯。
    *   *效果*: 彻底终结了在不同脚本中手动修改 `velocity` 导致的惯性不统一问题。

## 3. 有限状态机 (Finite State Machine, FSM)
为了解决 `_physics_process` 中无限嵌套的 `if...else`（即面条代码），我们引入了标准的 FSM 架构：

### 核心组成
*   **State基类**: 每个状态（Idle, Move, Attack）都是一个独立的脚本类。
*   **FSM控制器**: 负责状态切换的分发，确保同一时间只有一个状态执行。

### 实践案例：怪物 AI
*   **IdleState**: 监控玩家进入视野。
*   **ChaseState**: 处理寻路更新（加入随机偏移，优化性能）。
*   **AttackState**: 发动攻击，锁定移动，等待回调。
*   *收益*: 添加新行为（如“逃跑”）只需创建一个新文件，无需触动现有的追击逻辑。

## 4. 表现层“被动性”原则
为了实现逻辑与表现的彻底解耦，我们强化了视觉层的被动性：
*   **指令化**: 逻辑层只管发出信号（如 `state_changed`），表现层（Visual）作为“监听者”决定怎么播动画、播什么音效。
*   **优势**: 极大减少了 Bug 的耦合性。如果动画播错了，只需检查信号，而不需要在物理逻辑里翻找。

## 5. 架构守则 (Mandatory Rules)
*   **禁止跨组件直接调用**: 组件 A 与组件 B 的通信必须通过父节点 `Entity` 转发信号。
*   **状态单一化**: 逻辑分支必须放入状态机，不再允许在 `Entity` 的每帧循环中写业务逻辑判断。

---
*最后更新日期: 2026年1月18日*
