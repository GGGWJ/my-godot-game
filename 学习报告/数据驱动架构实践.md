# 学习报告：数据驱动架构 (Data-Driven Architecture)

## 1. 核心理念
为了实现“不改代码调数值”，我们将逻辑代码与数值配置彻底分离。这种模式允许策划或开发人员在不打开复杂场景文件（.tscn）的情况下，批量调整游戏平衡性。

## 2. 核心组件：.gd 与 .tres 的分工

### 脚本文件 (.gd) —— “数据的模具”
*   **存放位置**: `src/framework/stats/`
*   **角色**: 定义数据的**结构**。
*   **作用**:
    *   **定义字段**: 规定了一个实体应该有哪些属性（如 `max_health`, `speed`, `cooldown`），类似表头。
    *   **提供界面**: 通过 `@export` 关键词，在 Godot 编辑器右侧提供人类可读的输入框。
    *   **类型安全**: 在脚本中提供自动补全，防止写错属性名。

### 资源文件 (.tres) —— “数据的实体”
*   **存放位置**: `resources/stats/`
*   **角色**: 存储具体的**数值**。
*   **作用**:
    *   **数值存档**: 将平衡性参数（如 10 伤害还是 20 伤害）独立存储，类似填在表里的具体数值。
    *   **快速调整**: 直接双击 `.tres` 即可在编辑器中修改参数，且修改后实时生效。
    *   **批量更新**: 多个同类怪物（如一群骷髅）可以引用同一个 `.tres` 文件。

## 3. 实现细节 (Implementation)

### 属性覆盖机制 (Property Overriding)
在组件代码中（如 `AbilityDealDamage`），我们遵循以下优先级规则：
1. **优先读取**: 检查技能是否绑定了 `AbilityStats` 资源。
2. **动态注入**: 如果绑定了资源，优先从资源的 `parameters` 字典中获取数值。
3. **本地回退**: 如果未绑定资源或资源中无此参数，则回退到脚本本身的 `@export` 变量默认值。

### 收益总结
*   **解耦**: 逻辑代码不再关心具体数值是多少。
*   **动态化**: 方便未来接入 Excel/CSV 自动导表。
*   **升级系统**: 技能升级只需在运行时切换引用的 `.tres` 文件，即可完成所有数值的整体跨越。

## 4. 协作守则
*   **严禁数值硬编码**: 禁止将技能的基础伤害等关键数值写死在逻辑脚本里。
*   **规范命名**: `.tres` 文件应放在对应的子目录下（如 `enemies/`, `abilities/`），并保持清晰的命名习惯。
